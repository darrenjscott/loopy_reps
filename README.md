# Loopy Reps

***Note this package is incomplete. It only includes integrals I actually used -- much of the functionality is a bit hacky, but I know some people found it useful***  
**Make sure the load the package AFTER FormCalc**

Small Mathematica package for replacing the Feynman integrals generated by `FormCalc` ([link](https://feynarts.de/formcalc/)) with their analytic equivalents. The analytic forms have been derived from `Package-X` (originally developed by Hiren Patel but now seems to be maintained by Yannick Ulrich [here](https://gitlab.com/mule-tools/package-x)).

At its heart it is just a set of replacements I found useful at times in my research. In particular, it keeps track of and labels UV and IR singularities separately if you are as neurotic as tracking these individually through your calculation as I was. 

## Usage
### LoopyReps.m
#### To use ("installation")
Should be loaded after `FormCalc`.

``>>FormCalc` ``  
``>>LoopyReps` ``

#### Useful functions

This file simply contains a bunch (*incomplete*) of integral replacements for the integrals which `FormCalc` spits out in one-loop calculations.
There are some useful functions:  

1. **int0**  
   Replaces integrals which are genuinely zero by 0. Note, some integrals which are "zero" because they are scaleless are not treated by this because I have specifically tried to keep track of UV and IR poles separately.

2. **intCancel**  
   Since some integrals have simple expressions in terms of other simple integrals, this makes some replacements which might help simplify the expression you are working with. Here is an example:

   $$ B_0(\mathrm{bb}0,0,0,m_1^2) \rightarrow \frac{1}{m_1^2} A_0(m_1^2)$$
   > `In[1]=  B0i[bb0,0,0,m2] // intCancel`  
   > `Out[1]= A0[m2]/m2`
   

3. **intDiv**  
  Replaces integrals with their explicit divergences (`1/eUV` and `1/eIR` in Mathematica - note these are the letter `e`, trying to use `\\[Epsilon]` was causing trouble) and leaves the finite part of the integral abbreviated in a function with the `Fin` suffix. Example:

   $$ B_0(\mathrm{bb}0, m_1^2, 0, m_2^2) \rightarrow \frac{1}{\varepsilon_{\rm UV}} + B_{\mathrm{Fin},0}(\mathrm{bb}0, m_1^2, 0, m_2^2)$$  
   >`In[1]=   B0i[bb0,m12,0,m22] //intDiv`  
   >`Out[1]= 1/eUV+B0iFin[bb0,m12,0,m22]`

4. **localFix**
   This is supposed to deal with the finite terms which are generated when a `Dminus4` from the numerator of a loop integral results in a pole which cancels with one in the denominator. In `FormCalc` these are tagged with the `Finite` tag. The `localFix` is supposed to generate these finite parts by taking the `Dminus4` terms and working out the finite parts generated. The implementation of this is not the best and therefore there is a `localFix2` command which can also be used for testing - the source code for this is simple enough you should be able to see where the issue is if you have problems. Example:

   >`In[1]=  Dminus4 MW2/eUV //localFix`  
   >`Out[1]= -2 Finite MW2`

5. **intFin**
   Replaces the `Fin` suffixed integrals introduced by **intDiv** with their actual finite expressions which can be evaluated in vanilla Mathematica. Example:

   $$B_{\mathrm{Fin},0}(\mathrm{bb}0, m_1^2, 0, m_2^2)  \rightarrow 2 + \frac{1}{m_1^2} \left( (m_1^2-m_2^2) \ln\left(\frac{m_2^2}{m_2^2-m_1^2}\right) \right) + \ln\left(\frac{\mu^2}{m_2^2}\right)$$  

   >`In[1]=  B0iFin[bb0,m12,0,m22] //intFin`  
   >`Out[1]= 2 + ((m12-m22) Log[m22/(-m12+m22)])/m12+Log[\[Mu]^2/m22]`


#### Example usage of above functions
Adding a UV counterterm to your amplitude and collecting the finite remainders of the integrals

`virtualAmpUVFinite = 
  Collect[(Combine[ampVirtual, countertermAmp] //. Subexpr[] // int0 // 
           intCancel // intDiv // localFix) /. Finite -> 1 //. 
      M$FACouplings /. reals, {Mat[x__], A0Fin[x__], 
    B0iFin[x__], C0iFin[x__]}];`

  Note the `reals` replacement rules above is something I used to convert things like `Conjugate[eUV]` simply to `eUV`.

  Later on (probably after squaring, summing, adding to real contributions whatever) you can use `intFin` to get the explicit expression.
